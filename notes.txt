1. npm i eslint @eslint/js prettier eslint-config-prettier -D

"lint": "eslint .",
    "lint:fix": "eslint . --fix",
    "format": "prettier --write .",
    "format:check": "prettier --check ."



2. Setup prisma
    Note: First prepare postgress in neondb (https://console.neon.tech/)


    üß© Step 1: Install Prisma packages

                npm install prisma@5.16.1 @prisma/client@5.16.1



            npm install prisma@5.16.1 --save-dev
            npm install @prisma/client@5.16.1


            üëâ Explanation:
            prisma ‚Üí CLI tool for schema, migrations, and code generation.
            @prisma/client ‚Üí The actual runtime client your code will import.

    ‚öôÔ∏è Step 2: Initialize Prisma in your project

            npx prisma init


            This command will:

            ‚úÖ Create a new folder prisma/
            ‚úÖ Add a schema.prisma file inside it
            ‚úÖ Create a .env file at your project root with:

            DATABASE_URL="postgresql://user:password@localhost:5432/mydb?schema=public"
    üß† Step 3: Edit your .env

            If using Neon, replace it with your real connection string:
            DATABASE_URL="postgresql://<user>:<password>@<host>.neon.tech/<database>?sslmode=require"


            Example:
            DATABASE_URL="postgresql://bratati:secret@ep-cool-host.ap-southeast-1.aws.neon.tech/mydb?sslmode=require"
    
    üß± Step 4: Define your Prisma schema

            Open prisma/schema.prisma and modify like this:

            generator client {
                provider = "prisma-client-js"
            }

            datasource db {
                provider = "postgresql"
                url      = env("DATABASE_URL")
            }

            model User {
                id        Int      @id @default(autoincrement())
                email     String   @unique
                name      String?
                createdAt DateTime @default(now())
            }


    ‚ö° Step 5: Run Migration
            When you define or change models, run:

            npx prisma migrate dev --name init


            ‚úÖ This will:

            Create a new migration file under prisma/migrations/

            Apply schema to your Neon database

            Generate the Prisma client
    
    üß∞ Step 6: Generate the client manually (optional)

            If you ever need to regenerate Prisma client (after schema change):

            npx prisma generate

            or

            npx prisma generate --schema=./prisma/schema.prisma
    
    üß™ Step 7: Test your connection

            Create a file test.js:

            import { PrismaClient } from '@prisma/client';
            const prisma = new PrismaClient();

            async function main() {
            const user = await prisma.user.create({
                data: { email: 'hello@neon.tech', name: 'Neon User' },
            });
            console.log('Created user:', user);

            const allUsers = await prisma.user.findMany();
            console.log('All users:', allUsers);
            }

            main()
            .catch(console.error)
            .finally(async () => await prisma.$disconnect());


            Run it:

            node test.js


            If it outputs your user data ‚Üí ‚úÖ You‚Äôre connected successfully to Neon via Prisma!


3. Setup test

    npm install --save-dev jest
    npm install --save-dev supertest
    npm install --save-dev cross-env

    npm init jest@latest

    package.json
    ------------
    "imports": {
        "#src/*: "./src/*"
        .
        .
        .
    },
    "scripts": {
        "test": "cross-env NODE_OPTIONS=--experimental-vm-modules jest"
    }

    jest.config.mjs
    ---------------
    testEnvironment: "node",


4. To run a docker image with volume mount in windows host machine
    docker run -p 5173:5173 -e CHOKIDAR_USEPOLLING=true -e WATCHPACK_POLLING=true -v "${PWD}:/app" -v /app/node_modules vite-project


5. docker compose up --build
    docker tag kubernetes-demo-api:latest dubratati987/docker-acquisitions:latest
     docker push dubratati987/kubernetes-demo-api:latest 


6. Create docker image from terminal
    docker-compose -f docker-compose.local.yml up -d --build <service name, for example: app> 


---------------------------------------------------------------------------

docker
======

1. Build docker image from current docker context

    docker build -t acquisitions-app:local .


2. Build docker image from docker compose

    docker-compose -f docker-compose.local.yml build app
    docker tag acquisitions-app:latest acquisitions-app:local



How to prepare base64 of a string
=================================

Open WSL

In terminal write down

echo -n "random value" | base64




Minikube
========

1. Start Minikube   
        minikube Start

2. Enable Ingress
        minikube addons enable ingress

3. Check if ingress enabled 
        kubectl get pods -n ingress-nginx 

2. Create bridg between your machine and Kubernetes cluster
        minikube tunnel

3. Load docker image into minikube  
        minikube image load acquisitions-app:latest 

4. Delete docker image from minikube
        minikube image rm acquisitions-app:latest 2>$null

3. Minikube list image  
        minikube image ls


3. Minikube dashboard access
         minikube dashboard

          minikube addons enable metrics-server


kubectl
=======

1. Apply yaml file for configmap
        kubectl apply -f k8s/configmap.yaml

2. Get config map
        kubectl -n acquisition get configmap app-config -o yaml

3. Apply yaml file for secret   
        kubectl apply -f k8s/secret.yaml

4. Get secret
        kubectl -n acquisition get secret app-secret -o yaml


3. Apply yaml file in kubctl
        kubectl apply -f k8s/01-postgress.yaml

4. Delete objects in kubectl from yaml file
        kubectl delete -f k8s/01-postgress.yaml

5. Get all namespace
        kubectl get namespace

4. Get all services in kubectl
        kubectl -n acquisition get pod,svc -o wide

        OR

        kubectl -n acquisition get svc -l app=backend -o wide

4. Get all in progress POD
        kubectl -n acquisition wait --for=condition=ready pod -l app=backend --timeout=180s

4. Get PODs
        kubectl get pods -n acquisition -o wide
        OR
        kubectl -n acquisition get pod -l app=backend -o wide

5. Describe POD
        kubectl -n acquisition describe pod -l app=backend

5. Get POD logs 
        kubectl logs -n acquisition <pod name> -f

6. Shell acces to POD
        kubectl exec -it <pod name> -n acquisition -- sh


7. Port forward of minikube
        kubectl -n acquisition port-forward svc/backend 3000:3000

8. Apply ingress        
        kubectl apply -f k8s/04-ingress.yaml

9. Go to Windows\System32\drivers\etc and following at end of file
        127.0.0.1       appdemo.local

10. Get ingress
        kubectl -n acquisition get ingress

11. Describe ingress
        kubectl -n acquisition describe ingress <name>

13. Get services that using load balancer/ NodePort
        kubectl -n acquisition get svc -A | grep NodePort

14. To delete a pod
        kubectl -n acquisition delete pod -l app=db

15. To apply persistant volume claim
        kubectl apply -f .\k8s\postgress-pvc.yaml

16. To restart deployment
        kubectl -n acquisition rollout restart deploy/db-deployment

17. To check deployment rollout status
        kubectl -n acquisition rollout status deploy/db-deployment

18. If PVC is being used
        kubectl -n acquisition get pvc


Other notes
===========
1. Delete the namespace and everything inside it (full cleanup).
kubectl delete namespace acquisition

2. Delete pvc
kubectl -n devops-part3 delete pvc --all




If need to debug migration
-------------------------
kubectl -n acquisition get pod -l app=backend -o wide
kubectl -n acquisition logs <pod name> -c migrate



How to run
-----------
Open 3 terminals

In terminal: 1 => Start minkube tunnel
    1. minikube start

    2. minikube tunnel

In terminal: 2 => PORT forward

    kubectl -n acquisition port-forward svc/backend 3000:3000
    
In terminal: 3 => check log

    
    1. kubectl -n acquisition get pod -l app=backend -o wide

    2. kubectl -n acquisition logs <pod name> -f


----------------------


To create base64 encoded string type in WSL command line
echo -n 'acquisition_password' | base64
